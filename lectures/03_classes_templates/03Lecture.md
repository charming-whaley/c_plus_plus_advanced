# Лекция 3. Шаблоны классов

## 3.1 Частичный порядок

<p>Шаблон может выиграть перегрузку</p>

```c++
// Пример 1 - более очевидный
void foo(double x);

template<typename T>
void foo(T x);

foo(1); // <- это вариант с шаблоном, а не double

// Пример 2 - более нетривиальный
template<typename T> 
void f(T);

template<typename T> 
void f(T*);

int ***a;
foo(a); // <- здесь выберется вариант с указателем, то есть, с параметром T*
```

<p>Во втором примере логика немного другая: и специализация, и инстанцирование, и вывод типов работают одновременно.</p>

## 3.2 Имена в шаблонах

<p>Рассмотрим следующий код:</p>

```c++
int y = 2; { int y = y; }
int x = 2; { int x[x]; }
```

<p>В данном примере первая строка является <b>UB</b>, так как так называемся точка определения объекта с именем <b>y</b> начинается в внутреннем scope, а поэтому не понятно как мы можем дать <b>y</b> значение <b>y</b></p>

## 3.3 Частичная специализация
## 3.4 Трюк Саттера
## 3.5 Шаблоны членов
## 3.6 Параметризация методов и переходники