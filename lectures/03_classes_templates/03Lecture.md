# Лекция 3. Шаблоны классов

## 3.1 Частичный порядок

<p>Шаблон может выиграть перегрузку</p>

```c++
// Пример 1 - более очевидный
void foo(double x);

template<typename T>
void foo(T x);

foo(1); // <- это вариант с шаблоном, а не double

// Пример 2 - более нетривиальный
template<typename T> 
void f(T);

template<typename T> 
void f(T*);

int ***a;
foo(a); // <- здесь выберется вариант с указателем, то есть, с параметром T*
```

<p>Во втором примере логика немного другая: и специализация, и инстанцирование, и вывод типов работают одновременно.</p>

## 3.2 Имена в шаблонах

<p>Рассмотрим следующий код:</p>

```c++
int y = 2; { int y = y; }
int x = 2; { int x[x]; }
```

<p>В данном примере первая строка является <b>UB</b>, так как так называемся точка определения объекта с именем <b>y</b> начинается в внутреннем scope, а поэтому не понятно как мы можем дать <b>y</b> значение <b>y</b>.</p>

<p>Точка определения (PoD) - это граница, в которой завершено объявление. До PoD имя не считается введённым в область видимости.</p>

```c++
template<typename T>
struct fwnode /* PoD */ {
    T data_;
    fwnode *next_;
}

template<typename T> class Stack {
    fwnode<T> *top_;
}
```

<p>Таким образом, например, мы можем использовать имя нашего объекта (допустим структуры) внутри тела структуры.</p>

<p>Рассмотрим следующий код:</p>

```c++
#include <iostream>

template<typename T> struct D {
    enum { max = 10 };
};

char buffer[D<void>::max];
extern void clear(char* buf);

int main(int argc, const char* argv[]) {
    std::cout << "Requesting to clean " << D<void>::max << std::endl;
    clear(buffer);
}
```

<p>Данный код является корректным, однако опасным. Все дело в том, что тип <b>void</b> в данном случае не совсем уместен, так как <b>void</b> - неполный тип.</p>



## 3.3 Частичная специализация
## 3.4 Трюк Саттера
## 3.5 Шаблоны членов
## 3.6 Параметризация методов и переходники